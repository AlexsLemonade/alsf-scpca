---
title: "Alevin Kallisto comparisons"
author: "Joshua Shapiro for CCDL"
output: 
  html_notebook:
    toc: true
    toc_float: true
---

This notebook contains analysis of some initial benchmarking in runs of Alevin and Kallisto

## Setup

### Load Libraries
```{r setup}
library(ggplot2)
library(magrittr)
library(SingleCellExperiment)
library(DropletUtils)
library(tximport)

# set seed
set.seed(2020)
```



### File and directory setup
```{r}
data_dir <- file.path("data", "quants")
dir.create(data_dir, recursive = TRUE, showWarnings = FALSE)

alevin_data_dir <- file.path(data_dir, "alevin")
dir.create(alevin_data_dir, recursive = TRUE, showWarnings = FALSE)
quant_s3_alevin <- "s3://nextflow-ccdl-results/scpca-benchmark/quants/alevin"

kallisto_data_dir <- file.path(data_dir, "kallisto")
dir.create(kallisto_data_dir, recursive = TRUE, showWarnings = FALSE)
quant_s3_kallisto <- "s3://nextflow-ccdl-results/scpca-benchmark/quants/kallisto"

```

### Sync S3 files

```{r}
sync_call <- paste("aws s3 sync", quant_s3_alevin, alevin_data_dir)
system(sync_call, ignore.stdout = TRUE)

# exclude bus files, which are large
sync_call <- paste("aws s3 sync", quant_s3_kallisto, kallisto_data_dir, 
                   '--exclude "*/bus/*"')
system(sync_call, ignore.stdout = TRUE)
```

Get the sample list and make a data frame with sample info

```{r}
quant_dirs <- list.dirs(c(alevin_data_dir, kallisto_data_dir),
                        full.names = FALSE, recursive = FALSE)


# split ids into components for later processing
# expect some NA fills for kallisto, which doesn't have decoys, replace with "no"
quant_info <- data.frame (quant_dir = quant_dirs, info = quant_dirs) %>%
  tidyr::separate(info, sep = "[-]", 
                  into = c("sample", "index_type")) %>%
  tidyr::separate(index_type, 
                  into = c("tool", "index_content", "decoy"), 
                  extra = "drop") %>%
  dplyr::mutate(decoy = tidyr::replace_na(decoy, "no"))
  
```

### Get Annotations from AnnotationHub

```{r }
hub = AnnotationHub::AnnotationHub(ask = FALSE)
# Ensembl v100 Homo sapiens is AH79689
ensdb = hub[["AH79689"]]
ensg <- genes(ensdb)
```

Create vectors of mitochondrial genes and coding genes for later.

```{r}
# create the mitochondrial gene list
mito_genes <- ensg[seqnames(ensg) == 'MT']$gene_id

coding_genes <- ensg[ensg$gene_biotype == "protein_coding"]$gene_id
```

## Process quantification files

### Alevin

Use tximport to make SCEs

```{r}
alevin_quant_ids <- quant_info %>%
  dplyr::filter(tool == "alevin") %>%
  dplyr::pull(quant_dir)

alevin_sces <- alevin_quant_ids  %>%
  purrr::map(
    ~ tximport(file.path(alevin_data_dir, .x, "alevin", "quants_mat.gz"),
               type = "alevin")) %>%
  purrr::map(
    ~ SingleCellExperiment(list(counts = .x$counts))) 

# add names
names(alevin_sces) <- alevin_quant_ids
```

Calculate cell and feature QC statistics for each sample

```{r}
alevin_sces <- alevin_sces %>% 
  purrr::map(
    ~ scater::addPerCellQC(
      .x,
      subsets = list(mito = mito_genes[mito_genes %in% rownames(.x)])
    ) 
  ) %>%
  purrr::map(scater::addPerFeatureQC)
```

Make a data frame of the cell QCs.
```{r}
alevin_cell_qc <- alevin_sces %>%
  purrr::map_df( ~ as.data.frame(colData(.x)) %>%
                   tibble::rownames_to_column(var = "cell_id"),
                 .id = "quant_id") %>%
  dplyr::left_join(quant_info, by = c("quant_id" = "quant_dir"))
```

Summarize the total UMIs per cell.
```{r}
summary(alevin_cell_qc$sum)
```

Summarize the number of detected genes per cell.
```{r}
summary(alevin_cell_qc$detected)
```


### Kallisto

Get file basenames (no extension) for import

```{r}
kallisto_quant_ids <- quant_info %>%
  dplyr::filter(tool == "kallisto") %>%
  dplyr::pull(quant_dir)

base_file <- file.path(kallisto_data_dir, kallisto_quant_ids, "counts", "gene_count")
```

#### Function for reading Kallisto files

Takes a base file name and reads the the `.mtx` file and associated `.barcodes.txt` and `.genes.txt` files.  
Filters cells/barcodes based on the knee plot using `DropletUtils::barcodeRanks()`
```{r}
read_kallisto_counts <- function(base, cellfilter = c("knee", "none")){
  cellfilter <- match.arg(cellfilter)
  counts <- Matrix::readMM(paste0(base,".mtx"))%>%
    t() %>% # transpose to gene x cell orientation
    as("dgCMatrix") # compress sparse matrix
  dimnames(counts) <- list(readLines(paste0(base,".", "genes.txt")),
                           readLines(paste0(base,".barcodes.txt")))
  if(cellfilter == "knee"){
    # calculate ranks and find knee
    rank_df <- DropletUtils::barcodeRanks(counts)
    cells <- which(rank_df$total >= metadata(rank_df)$knee)
    counts <- counts[, cells]
  }
  return(counts)
}
```

Make a list of kallisto runs as SCEs
```{r}
kallisto_sces <- base_file %>%
  purrr::map(read_kallisto_counts) %>%
  purrr::map(~ SingleCellExperiment(list(counts = .x))) 

# add names
names(kallisto_sces) <- kallisto_quant_ids
```

Calculate cell and feature QC statistics for each sample

```{r}
kallisto_sces <- kallisto_sces %>% 
  purrr::map(
    ~ scater::addPerCellQC(
      .x,
      subsets = list(mito = mito_genes[mito_genes %in% rownames(.x)])
    ) 
  ) %>%
  purrr::map(scater::addPerFeatureQC)
```

Make a table of the SCE cell QCs.
```{r}
kallisto_cell_qc <- kallisto_sces %>%
  purrr::map_df(~ as.data.frame(colData(.x)) %>%
                  tibble::rownames_to_column(var = "cell_id"),
                .id = "quant_id") %>%
  dplyr::left_join(quant_info, by = c("quant_id" = "quant_dir"))
```

```{r}
summary(kallisto_cell_qc$sum)
```

Summarize the number of detected genes per cell.
```{r}
summary(kallisto_cell_qc$detected)
```

## Comparing kallisto and alevin summary stats

Combine the two data frames:
```{r}
cell_qc <- dplyr::bind_rows(alevin_cell_qc, kallisto_cell_qc)
```

Plot distributions of Total UMI counts
```{r}
ggplot(cell_qc, aes(x = sum, color = index_content)) +
  geom_density() +
  xlab("Total UMI count") +
  facet_grid(tool ~ decoy)
```
Plot distributions of Detected gene counts
```{r}
ggplot(cell_qc, aes(x = detected, color = index_content)) +
  geom_density() +
  xlab("Detected genes") +
  facet_grid(tool ~ decoy)
```
Kallisto tends to detect more UMIs and more transcripts per cell. 

Lets make a little table:
```{r}
cell_qc %>%
  dplyr::group_by(index_content, tool, decoy) %>%
  dplyr::summarize(dplyr::across(
    c(sum, detected, subsets_mito_percent),
    mean))
```


So, the naive conclusion is that Kallisto is mapping many more UMIs per cell, and capturing more genes.
Is this because we are excluding low count cells in the knee plot? 
```{r}
cell_qc %>%
  dplyr::group_by(index_content, tool, decoy) %>%
  dplyr::tally()
```
Ugh, maybe. 

Lets filter to the cells that are included with all methods and repeat this.
These will be cells where the count of the cell_id is 3 for txome or cdna, handled separately.

```{r}
cell_counts <- cell_qc %>%  
  dplyr::count(index_content, cell_id)

common_cells_cdna <- cell_counts %>%
  dplyr::filter(index_content == "cdna", n == 3) %>%
  dplyr::pull(cell_id)

common_cells_txome <- cell_counts %>%
  dplyr::filter(index_content == "txome", n == 3) %>%
  dplyr::pull(cell_id)

cell_qc_common <- cell_qc %>%
  dplyr::filter(
    (index_content == "cdna" & cell_id %in% common_cells_cdna) 
    | (index_content == "txome" & cell_id %in% common_cells_txome) 
  )
```


```{r}
ggplot(cell_qc_common, aes(x = sum, color = index_content)) +
  geom_density() +
  xlab("Total UMI count") +
  facet_grid(tool ~ decoy)
```
Plot distributions of Detected gene counts
```{r}
ggplot(cell_qc_common, aes(x = detected, color = index_content)) +
  geom_density() +
  xlab("Detected genes") +
  facet_grid(tool ~ decoy)
```
More similar, but still kallisto finds more per cell.

```{r}
cell_qc_common %>%
  dplyr::group_by(index_content, tool, decoy) %>%
  dplyr::summarize(dplyr::across(
    c(sum, detected, subsets_mito_percent),
    mean))
```

