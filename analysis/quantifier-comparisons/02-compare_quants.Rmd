---
title: "SCRNAseq quantification comparisons"
author: "Joshua Shapiro for CCDL"
output: 
  html_notebook:
    toc: true
    toc_float: true
---


## Setup

### Load Libraries
```{r setup}
library(ggplot2)
library(magrittr)
library(SingleCellExperiment)

# set seed
set.seed(2020)
```



### File and directory setup
```{r}
# Files and dirs generated by 01-import-quant-data.Rmd

import_dir <- 'data'

quant_info_file <- file.path(import_dir, 'quant_info.tsv')

alevin_rds <- file.path(import_dir, 'alevin_sces.rds')
kallisto_rds <- file.path(import_dir, 'kallisto_sces.rds')
cellranger_rds <- file.path(import_dir, 'cellranger_sces.rds')


```

### Read in data files

```{r}
quant_info <- readr::read_tsv(quant_info_file )

alevin_sces <- readr::read_rds(alevin_rds)
kallisto_sces <- readr::read_rds(kallisto_rds)
cellranger_sces <- readr::read_rds(cellranger_rds)
```


### Get Annotations from AnnotationHub

```{r }
hub = AnnotationHub::AnnotationHub(ask = FALSE)
# Ensembl v100 Homo sapiens is AH79689
ensdb = hub[["AH79689"]]
ensg <- genes(ensdb)
```

Create vectors of mitochondrial genes and coding genes for later.

```{r}
# create the mitochondrial gene list
mito_genes <- ensg[seqnames(ensg) == 'MT']$gene_id

coding_genes <- ensg[ensg$gene_biotype == "protein_coding"]$gene_id
```

## Calculate cell QC statistics

A small function to set default QC calculations for SCEs in a list:
```{r}
addPerCellQC_mito <- function(sce, mito = mito_genes){
  scater::addPerCellQC(
    sce, 
    subsets = list(mito = mito[mito %in% rownames(sce)])
  )
}
```

Calculate cell QC statistics for each set of SCES

```{r}
alevin_sces <- alevin_sces %>% 
  purrr::map(addPerCellQC_mito)

kallisto_sces <- kallisto_sces %>% 
  purrr::map(addPerCellQC_mito)

cellranger_sces <- cellranger_sces %>% 
  purrr::map(addPerCellQC_mito)
```

Make a data frames of the cell QCs.
```{r}
celldata_to_df <- function(sce){
  as.data.frame(colData(sce)) %>%
  tibble::rownames_to_column(var = "cell_id")
}

alevin_cell_qc <- alevin_sces %>%
  purrr::map_df(celldata_to_df, .id = "quant_id")

kallisto_cell_qc <- kallisto_sces %>%
  purrr::map_df(celldata_to_df, .id = "quant_id")

cellranger_cell_qc <- cellranger_sces %>%
  purrr::map_df(celldata_to_df, .id = "quant_id")

# combine all the data frames into one
cell_qc <- dplyr::bind_rows(
  alevin = alevin_cell_qc,
  kallisto = kallisto_cell_qc,
  cellranger = cellranger_cell_qc,
  .id = "tool"
) %>%
  dplyr::left_join(quant_info,
                   by = c("tool" = "tool", 
                          "quant_id" = "quant_dir"))
```

## Comparing summary stats across tools

Plot distributions of Total UMI counts
```{r}
ggplot(cell_qc, aes(x = sum, color = sample)) +
  geom_density() +
  xlab("Total UMI count") +
  facet_grid(tool ~ decoy)
```

Plot distributions of Detected gene counts
```{r}
ggplot(cell_qc, aes(x = detected, color = sample)) +
  geom_density() +
  xlab("Detected genes") +
  facet_grid(tool ~ decoy)
```
Kallisto tends to detect more UMIs and more transcripts per cell. 

Lets make a little table:
```{r}
cell_qc %>%
  dplyr::group_by(sample, tool, decoy) %>%
  dplyr::summarize(dplyr::across(
    c(sum, detected, subsets_mito_percent),
    mean)) %>%
  dplyr::rename("mean UMI count" = "sum", 
                "mean detected genes" = "detected", 
                "mean mitochondiral percent" = "subsets_mito_percent")
```


So, the naive conclusion is that Kallisto is mapping many more UMIs per cell, and capturing more genes (which reduces the mitochondrial percentage).

Is this because we are excluding low count cells in the knee plot? 
```{r}
cell_qc %>%
  dplyr::group_by(sample, tool, decoy) %>%
  dplyr::tally()
```
Ugh, maybe. Cellranger consistently keeps the most cells, with kallisto the fewest.

Lets filter to the cells that are included with all methods and repeat this.
These will be cells where the count of the cell_id is 4 (2 alevin types, + cellranger and kallisto)

```{r}
cell_counts <- cell_qc %>%  
  dplyr::count(cell_id, sample)

common_cells <- cell_counts %>%
  dplyr::filter(n == 4) %>%
  dplyr::pull(cell_id)

cell_qc_common <- cell_qc %>%
  dplyr::filter(
    (cell_id %in% common_cells) 
  )
```


```{r}
ggplot(cell_qc_common, aes(x = sum, color = sample)) +
  geom_density() +
  xlab("Total UMI count") +
  facet_grid(tool ~ decoy)
```
Plot distributions of Detected gene counts
```{r}
ggplot(cell_qc_common, aes(x = detected, color = sample)) +
  geom_density() +
  xlab("Detected genes") +
  facet_grid(tool ~ decoy)
```
More similar, but still kallisto finds more UMIs and genes per cell.

```{r}
cell_qc_common %>%
  dplyr::group_by(sample, tool, decoy) %>%
  dplyr::summarize(dplyr::across(
    c(sum, detected, subsets_mito_percent),
    mean))%>%
  dplyr::rename("mean UMI count" = "sum", 
                "mean detected genes" = "detected", 
                "mean mitochondiral percent" = "subsets_mito_percent")
```


## Gene-level correlations among methods

Before proceeding, we will filter our SCEs to the common set of cells for fair comparisons.

```{r}
#filter and add Feature QC
alevin_sces_reduced <- alevin_sces %>%
  purrr::map(~ .x[, colnames(.x) %in% common_cells]) %>%
  purrr::map(scater::addPerFeatureQC)

kallisto_sces_reduced <- kallisto_sces %>%
  purrr::map(~ .x[, colnames(.x) %in% common_cells]) %>%
  purrr::map(scater::addPerFeatureQC)

cellranger_sces_reduced <- cellranger_sces %>%
  purrr::map(~ .x[, colnames(.x) %in% common_cells]) %>%
  purrr::map(scater::addPerFeatureQC)
```


Combine all feature QC stats into a single data frame.
```{r}
genedata_to_df <- function(sce){
  as.data.frame(rowData(sce)) %>%
  tibble::rownames_to_column(var = "gene_id")
}

alevin_feature_qc <- alevin_sces_reduced %>%
  purrr::map_df(genedata_to_df, .id = "quant_id")

kallisto_feature_qc <- kallisto_sces_reduced %>%
  purrr::map_df(genedata_to_df, .id = "quant_id")

cellranger_feature_qc <- cellranger_sces_reduced %>%
  purrr::map_df(genedata_to_df, .id = "quant_id")


feature_qc <- dplyr::bind_rows(
  alevin = alevin_feature_qc, 
  kallisto = kallisto_feature_qc, 
  cellranger = cellranger_feature_qc,
  .id = "tool"
) %>%
  dplyr::left_join(quant_info,
                   by = c("tool" = "tool", 
                          "quant_id" = "quant_dir"))

```

Since some features are very rarely detected, we will eliminate those for the purposes of these comparisons.
Get features that were found in at least 5% of cells in at least three samples.
```{r}
detected_features <- feature_qc %>%
  dplyr::filter(detected >= 5.0) %>%
  dplyr::count(gene_id) %>%
  dplyr::filter(n >= 3) %>%
  dplyr::pull(gene_id)
# How many?
length(detected_features)
```

```{r}
# spread table for comparisons (no decoy samples)
feature_compare <- feature_qc %>%
  dplyr::filter(gene_id %in% detected_features,
                decoy == "no") %>%
  tidyr::pivot_wider(id_cols = c(gene_id, sample),
                     names_from = tool,
                     values_from = mean) %>%
  # add in the decoys
  dplyr::inner_join(feature_qc %>% 
                      dplyr::filter(decoy == "full") %>%
                      dplyr::select(gene_id,
                                    sample,
                                    alevin_decoy = mean ),
                    by = c("gene_id", "sample")) %>%
  tidyr::drop_na()
```

What do the correlations look like? We'll calculate Spearman correlations first, even though those may overemphasize some of the small differences, because they also won't be overwhelmed by the highly expressed genes.

```{r}
feature_compare %>% 
  dplyr::group_by(sample) %>%
  dplyr::summarize(
    cr_al_cor = cor(cellranger, alevin, method = "spearman"),
    cr_al_decoy_cor = cor(cellranger, alevin_decoy, method = "spearman"),
    cr_ka_cor = cor(cellranger, kallisto, method = "spearman"),
    al_ka_cor = cor(alevin, kallisto, method = "spearman")
  )
```

Overall, these seem like decent correlations, but the best correlations are between Cellranger and Alevin, with a slightly better correlation when we use the full decoy index.
I was somewhat surprised by the more divergent showing for Kallisto, but it does seem like it's speed does come with a tradeoff, at least as far as comparing to the "standard" of Cellranger.

Below are plots of the relationships among the callers.

```{r}
ggplot(feature_compare, aes(x = cellranger, y = alevin)) +
  geom_point(alpha = 0.1) + 
  facet_wrap(~ sample) + 
  scale_x_log10() + 
  scale_y_log10() + 
  labs(x = "Cell Ranger mean expression", y = "Alevin mean expression")
```
```{r}
ggplot(feature_compare, aes(x = cellranger, y = alevin_decoy)) +
  geom_point(alpha = 0.1) + 
  facet_wrap(~ sample) + 
  scale_x_log10() + 
  scale_y_log10() + 
  labs(x = "Cell Ranger mean expression", y = "Alevin Decoy mean expression")
```


```{r}
ggplot(feature_compare, aes(x = cellranger, y = kallisto)) +
  geom_point(alpha = 0.1) + 
  facet_wrap(~ sample) + 
  scale_x_log10() + 
  scale_y_log10() + 
  labs(x = "Cell Ranger mean expression", y = "Kallisto mean expression")
```


What seems apparent from these plots is that while all quantification methods are generally well correlated, especially for highly expressed genes, there is a class of genes for which the pseudomapping aligners are more likely to call a higher level of expression than Cell Ranger. 
This may be genes where multimapping occurs, as it is my understanding that Cell Ranger may discard multimapped transcripts.

This is most pronounced for Kallisto, perhaps because it does not perform a selective alignment step like Alevin does.
The decoy-aware mapping that Alevin can do improves correlations slightly. It may not be be a major benefit, but the runtime cost did not seem too high. 
Memory use was higher, but for the machines on AWS, this was not a concern, as there is plenty of available memory per CPU for all machines.

In the future, it may be interesting to explore which genes get the most "benefit" from the decoy index, as well as which genes are most divergent between Alevin and Kallisto. 
For now though, I think that is beyond the scope of this notebook.
